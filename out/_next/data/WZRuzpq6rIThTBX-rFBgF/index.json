{"pageProps":{"posts":[{"slug":"gcc-optimization-levels","frontmatter":{"title":"GCC Optimization Levels","date":"2022-08-10","tags":["debugger","gcc","avr"]},"content":"\nOptimization levels are really weird.\n\nUsing the function and compiling for an attiny85, ie [`--mmcu=attiny85`](https://www.nongnu.org/avr-libc/user-manual/using_tools.html).\n```\nint main(void) {\n    int i = 0;\n    while(i < 10000) {\n        i++;\n    }\n}\n```\n\nWe can disassemble with `avr-objdump -sS -m avr25 led`. As a disclaimer, I'm not pretending I know what any of this means.\n\nUsing `-Os` ie optimize for code side, it looks like the entire function is optimized away!\n```\n> avr-objdump -sS -m avr25 led\n...\n00000030 <main>:\n{\n    int i = 0;\n    while(i < 10000) {\n        i++;\n    }\n}\n  30:\t90 e0       \tldi\tr25, 0x00\t; 0\n  32:\t80 e0       \tldi\tr24, 0x00\t; 0\n  34:\t08 95       \tret\n```\n\nAnd by comparison, using `-O0`, fastest compile time and the gcc default:\n```\n00000030 <main>:\n// #include \"wait.h\"\n\nint main(void) {\n  30:\tcf 93       \tpush\tr28\n  32:\tdf 93       \tpush\tr29\n  34:\t00 d0       \trcall\t.+0      \t; 0x36 <L0^A>\n\n00000036 <L0^A>:\n  36:\tcd b7       \tin\tr28, 0x3d\t; 61\n  38:\tde b7       \tin\tr29, 0x3e\t; 62\n\n0000003a <.Loc.1>:\n    int i = 0;\n  3a:\t1a 82       \tstd\tY+2, r1\t; 0x02\n  3c:\t19 82       \tstd\tY+1, r1\t; 0x01\n\n0000003e <.Loc.2>:\n    while(i < 10000) {\n  3e:\t05 c0       \trjmp\t.+10     \t; 0x4a <.L2>\n\n00000040 <.L3>:\n        i++;\n  40:\t89 81       \tldd\tr24, Y+1\t; 0x01\n  42:\t9a 81       \tldd\tr25, Y+2\t; 0x02\n  44:\t01 96       \tadiw\tr24, 0x01\t; 1\n  46:\t9a 83       \tstd\tY+2, r25\t; 0x02\n  48:\t89 83       \tstd\tY+1, r24\t; 0x01\n\n0000004a <.L2>:\n    while(i < 10000) {\n  4a:\t89 81       \tldd\tr24, Y+1\t; 0x01\n  4c:\t9a 81       \tldd\tr25, Y+2\t; 0x02\n  4e:\t80 31       \tcpi\tr24, 0x10\t; 16\n  50:\t97 42       \tsbci\tr25, 0x27\t; 39\n  52:\tb4 f3       \tbrlt\t.-20     \t; 0x40 <.L3>\n  54:\t80 e0       \tldi\tr24, 0x00\t; 0\n  56:\t90 e0       \tldi\tr25, 0x00\t; 0\n\n00000058 <.Loc.5>:\n    }\n}\n  58:\t0f 90       \tpop\tr0\n  5a:\t0f 90       \tpop\tr0\n  5c:\tdf 91       \tpop\tr29\n  5e:\tcf 91       \tpop\tr28\n  60:\t08 95       \tret\n00000030 <main>:\n// #include \"wait.h\"\n\nint main(void) {\n  30:\tcf 93       \tpush\tr28\n  32:\tdf 93       \tpush\tr29\n  34:\t00 d0       \trcall\t.+0      \t; 0x36 <L0^A>\n\n00000036 <L0^A>:\n  36:\tcd b7       \tin\tr28, 0x3d\t; 61\n  38:\tde b7       \tin\tr29, 0x3e\t; 62\n\n0000003a <.Loc.1>:\n    int i = 0;\n  3a:\t1a 82       \tstd\tY+2, r1\t; 0x02\n  3c:\t19 82       \tstd\tY+1, r1\t; 0x01\n\n0000003e <.Loc.2>:\n    while(i < 10000) {\n  3e:\t05 c0       \trjmp\t.+10     \t; 0x4a <.L2>\n\n00000040 <.L3>:\n        i++;\n  40:\t89 81       \tldd\tr24, Y+1\t; 0x01\n  42:\t9a 81       \tldd\tr25, Y+2\t; 0x02\n  44:\t01 96       \tadiw\tr24, 0x01\t; 1\n  46:\t9a 83       \tstd\tY+2, r25\t; 0x02\n  48:\t89 83       \tstd\tY+1, r24\t; 0x01\n\n0000004a <.L2>:\n    while(i < 10000) {\n  4a:\t89 81       \tldd\tr24, Y+1\t; 0x01\n  4c:\t9a 81       \tldd\tr25, Y+2\t; 0x02\n  4e:\t80 31       \tcpi\tr24, 0x10\t; 16\n  50:\t97 42       \tsbci\tr25, 0x27\t; 39\n  52:\tb4 f3       \tbrlt\t.-20     \t; 0x40 <.L3>\n  54:\t80 e0       \tldi\tr24, 0x00\t; 0\n  56:\t90 e0       \tldi\tr25, 0x00\t; 0\n\n00000058 <.Loc.5>:\n    }\n}\n  58:\t0f 90       \tpop\tr0\n  5a:\t0f 90       \tpop\tr0\n  5c:\tdf 91       \tpop\tr29\n  5e:\tcf 91       \tpop\tr28\n  60:\t08 95       \tret\n```\n\nWith `-O1`:\n```\n00000030 <main>:\n// #include \"wait.h\"\n\nint main(void) {\n  30:\t80 e1       \tldi\tr24, 0x10\t; 16\n  32:\t97 e2       \tldi\tr25, 0x27\t; 39\n\n00000034 <.L2>:\n    int i = 0;\n    while(i < 10000) {\n  34:\t01 97       \tsbiw\tr24, 0x01\t; 1\n\n00000036 <.LVL2>:\n  36:\tf1 f7       \tbrne\t.-4      \t; 0x34 <.L2>\n\n00000038 <.Loc.8>:\n        i++;\n    }\n}\n  38:\t90 e0       \tldi\tr25, 0x00\t; 0\n  3a:\t80 e0       \tldi\tr24, 0x00\t; 0\n\n0000003c <.LVL3>:\n  3c:\t08 95       \tret\n```\n\nAnd finally with `-O2` and `-O3` we are back to optimizing everything away:\n```\n00000030 <main>:\nint main(void) {\n    int i = 0;\n    while(i < 10000) {\n        i++;\n    }\n}\n  30:\t90 e0       \tldi\tr25, 0x00\t; 0\n  32:\t80 e0       \tldi\tr24, 0x00\t; 0\n  34:\t08 95       \tret\n```\n\nSo I guess the TLDR here is try and test them all?\n"},{"slug":"temp-sensor","frontmatter":{"title":"Thermometer","date":"2022-07-21","tags":["thermometer"]},"content":"\nWhy buy a $10 thermometer when you can spend $100 and build one yourself in 15-20 hours?\n\n![Thermometer](/images/thermometer/thermometer.jpg)\n\nCaitlin kept saying the thermostat was off so I build this to find out. As a bonus, it also tells me my house is too humid so now I have to also figure that out. Fun.\n\nI was stubborn and wanted to use an attiny85 regardless of whether it was a good idea or not.\n5 pins isn't enough to control the display so I used a shift register as an IO expander to talk to the 1602 led display using SPI.\n\n![Prototype](/images/thermometer/prototype.jpg)\n\nThe temp/humidity sensor originally was an aht11 but apparently that unit is extremely sensitive to timing and I couldn't quite get it right with the attiny. I switched to an AM2301B and that used i2c for communication and worked really well.\n\nFirst try I soldered everything backwards but I eventually got it right.\n\n![Board](/images/thermometer/board.jpg)\n\n![Board2](/images/thermometer/board2.jpg)\n\n![Board3](/images/thermometer/board3.jpg)\n\n![Power Up](/images/thermometer/power-up.jpg)\n\nThe packing took forever and I ended up having to buy multiple project boxes to get the right size.\n\n![Packaging](/images/thermometer/packaging.jpg)\n\n![Assembly](/images/thermometer/assembly.jpg)\n\nAll done!\n\n![Final](/images/thermometer/final.jpg)\n"},{"slug":"bench-setup","frontmatter":{"title":"Bench Setup","date":"2022-07-16","tags":["bench"]},"content":"\n![Office](/images/office-early.jpg \"Office\")"},{"slug":"led-counter","frontmatter":{"title":"7 Segment LED Counter","date":"2022-07-15","tags":["led"]},"content":"\nThis was a funny project where I tried to build a simple 7 segment led counter without using a microcontroller. Each digit is controlled separately using 4026's and a sub 15 ms clock controlling which led is displayed, targeting a digit using a mux. 15 ms was chosen because it's faster than I could notice the counter changing, kinda like controlling led brightness using pwm. The counter ticks up based on a second slower clock or a button.\n\nI isolated the clocks into separate modules using 555 timers, both of which took forever to solder. One was in a fixed astable mode, the other a toggle-able monostable button debouncer or a bi-stable latch.\n\nRan out of diodes on this one...\n\n![LED Counter](/images/led-counter.jpg \"LED Counter\")\n"},{"slug":"first-oscillator","frontmatter":{"title":"Simple Oscillator","date":"2022-07-10","tags":["oscillator"]},"content":"\n![Oscillator](/images/first-oscillator.jpg \"An Oscillator\")\n\nProbably the first circuit I tried to solder together. An astable oscillator that was so\nastable the timing was all over the place!\n"}]},"__N_SSG":true}