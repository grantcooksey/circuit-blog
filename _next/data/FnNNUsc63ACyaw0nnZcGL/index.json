{"pageProps":{"posts":[{"slug":"dehumidifier-hack","frontmatter":{"title":"Dehumidifier Hack","date":"2022-11-12","tags":["hack"]},"content":"\nI hate lights in my room while I sleep and we've got a couple appliances that love to give some feedback that they are on.\n\n![Annoying lights](/images/hack-dehumidifier/start.jpg \"Annoying lights on a small dehumidifier\")\n\nAlthough it's not that bright, it still annoys the shit out of me so at some point I got the bright idea that I could probably swap out the leds with similar diode. I popped the top off and with the help of some solder wick and 2 1N4148 diodes, the design flaw was corrected.\n\nHere's the board with one of the swapped diodes and an original led.\n![Mid swap](/images/hack-dehumidifier/progress.jpg \"A circuit board with an original led and a replaced diode\")\n\nAnd with all leds swapped out.\n![All swapped](/images/hack-dehumidifier/swapped.jpg \"A circuit board with leds swapped with diodes\")\n\nPure bliss.\n![Finished](/images/hack-dehumidifier/done.jpg \"Dehumidifier with no power lights.\")\n"},{"slug":"avr-toolchain","frontmatter":{"title":"The AVR Toolchain","date":"2022-09-30","tags":["gnu","gcc","avr","binutils"]},"content":"\nOne of the goals I had when I started getting into the digital side of electronics was to get a good grasp of the GNU toolchain and some of the avr tools. The arduino platform is nice but it doesn't really give you a good grasp of what's actually happening so here's a primer from an attiny perspective and some of the common tools used to understand what's in the final binary.\n\n[There's already a great overview of the main avr toolchain](https://www.nongnu.org/avr-libc/user-manual/overview.html)), but this article provides some examples built against a simple binary to wrap your head around it all.\n\n# Tools\n\nAll of these examples are build with the attiny25 family in mind and uses a binary from a really dumb program in , `loop.c`:\n```\nint main(void) {\n    int i = 0;\n    while(i < 10000) {\n        i++;\n    }\n}\n```\n\nThis was compiled to the `loop` binary using `avr-gcc -g -mmcu=avr25 -o loop loop.c`\n* `-g` to add debugging symbols, gives an easier time linking back to the individual line of code.\n* ` -mmcu=avr25` specifies the AVR instruction set architecture to use. [Change this to whatever chip you're targeting.](https://gcc.gnu.org/onlinedocs/gcc/AVR-Options.html#AVR-Options)\n\nAt a high level, avr-libc provides a standard c library that can be compiled with gcc. The tools here are mostly provided through binutils and you would normally use make to stitch it all together.\n\n## Objdump\n\nThis is the swiss army knife to picking apart object files. Typically used to take a look at the disassembly:\n```\n> avr-objdump -m avr25 -S loop\n\nloop:     file format elf32-avr\n\nDisassembly of section .text:\n\n00000000 <main>:\nint main(void) {\n   0:\tcf 93       \tpush\tr28\n   2:\tdf 93       \tpush\tr29\n   4:\t00 d0       \trcall\t.+0      \t; 0x6 <L0^A>\n\n00000006 <L0^A>:\n   6:\tcd b7       \tin\tr28, 0x3d\t; 61\n   8:\tde b7       \tin\tr29, 0x3e\t; 62\n\n0000000a <.Loc.1>:\n    int i = 0;\n   a:\t1a 82       \tstd\tY+2, r1\t; 0x02\n   c:\t19 82       \tstd\tY+1, r1\t; 0x01\n\n0000000e <.Loc.2>:\n    while(i < 10000) {\n   e:\t05 c0       \trjmp\t.+10     \t; 0x1a <.L2>\n\n00000010 <.L3>:\n        i++;\n  10:\t89 81       \tldd\tr24, Y+1\t; 0x01\n  12:\t9a 81       \tldd\tr25, Y+2\t; 0x02\n  14:\t01 96       \tadiw\tr24, 0x01\t; 1\n  16:\t9a 83       \tstd\tY+2, r25\t; 0x02\n  18:\t89 83       \tstd\tY+1, r24\t; 0x01\n\n0000001a <.L2>:\n    while(i < 10000) {\n  1a:\t89 81       \tldd\tr24, Y+1\t; 0x01\n  1c:\t9a 81       \tldd\tr25, Y+2\t; 0x02\n  1e:\t80 31       \tcpi\tr24, 0x10\t; 16\n  20:\t97 42       \tsbci\tr25, 0x27\t; 39\n  22:\tb4 f3       \tbrlt\t.-20     \t; 0x10 <.L3>\n  24:\t80 e0       \tldi\tr24, 0x00\t; 0\n  26:\t90 e0       \tldi\tr25, 0x00\t; 0\n\n00000028 <.Loc.5>:\n    }\n  28:\t0f 90       \tpop\tr0\n  2a:\t0f 90       \tpop\tr0\n  2c:\tdf 91       \tpop\tr29\n  2e:\tcf 91       \tpop\tr28\n  30:\t08 95       \tret\n```\n\nThe `-S` flag attempts to intermix the original source code along with the assembly.\n\nThe output of this dump is a little confusing at first but let's break it down. Looking at the counter increment code:\n```\n# This is the address in the elf file and the associated debugging symbol <.L3>\n00000010 <.L3>:\n\n# We're looking at the increment instruction here\n        i++;\n\n# 10 is the address, 89 81 is the actual data.\n# objdump translates this to ldd\tr24, Y+1 for an attiny.\n  10:\t89 81       \tldd\tr24, Y+1\t; 0x01\n  12:\t9a 81       \tldd\tr25, Y+2\t; 0x02\n  14:\t01 96       \tadiw\tr24, 0x01\t; 1\n  16:\t9a 83       \tstd\tY+2, r25\t; 0x02\n  18:\t89 83       \tstd\tY+1, r24\t; 0x01\n```\n\n## Hexdump\n\nProbably not that useful but shows a raw view of the file.\n\n1 byte per line dump:\n```\n> hexdump -v -e '1/1 \"%02x \" \"\\n\"' loop\n7f\n45\n4c\n46\n01\n01\n01\n... a lot more is dumped\n```\n\n## Od - Octal Dump\n\nWay simpler to use than hexdump.\n\nNo address: `-An` and just text: `-a`.\n```\n> od -An -a loop\ndel   E   L   F soh soh soh nul nul nul nul nul nul nul nul nul\nstx nul   S nul soh nul nul nul nul nul nul nul   4 nul nul nul\n84  bs nul nul  em nul nul nul   4 nul  sp nul stx nul   ( nul\ncr nul  ff nul soh nul nul nul   t nul nul nul nul nul nul nul\n... once again, lots more dumped\n```\n\n## Size\n\nEasy way to see the sizes of each section.\n```\n> avr-size --format=SysV loop\nloop  :\nsection          size      addr\n.text              50         0\n.data               0   8388704\n.comment           36         0\n.debug_aranges     32         0\n.debug_info        85         0\n.debug_abbrev      78         0\n.debug_line        91         0\n.debug_frame       52         0\n.debug_str         95         0\nTotal             519\n```\n\n## Objcopy\n\nElf files contain a bunch of unnecessary sections that would be a waste to store in our limited flash space on the target, like all the debugging sections and comments. This command is similar to `strip` but also encodes the file from elf to various formats.\n\n### Intel hex\n\nMost microcontrollers code uploads use an ihex file format rather than an elf file.\n\nBuilding ihex from an elf:\n```\n> avr-objcopy -j .text -j .data -O ihex loop loop.hex && cat loop.hex\n:10000000CF93DF9300D0CDB7DEB71A82198205C037\n:1000100089819A8101969A83898389819A81803125\n:100020009742B4F380E090E00F900F90DF91CF9172\n:02003000089531\n:00000001FF\n```\n\n### Binary\n\nYou can take a look at the raw binary if hex is annoying to look at. Not that this is really useful outside of educational purposes.\n\n```\n# first dump to a binary file\n> avr-objcopy -O binary --only-section=.text main test.bin\n\n# Now display the binary for one instruction per line, `xxd` can handle the conversion:\n> xxd -b -c 2 test.bin\n00000000: 00001110 11000000  ..\n00000002: 00010101 11000000  ..\n00000004: 00010100 11000000  ..\n00000006: 00010011 11000000  ..\n00000008: 00010010 11000000  ..\n0000000a: 00010001 11000000  ..\n0000000c: 00010000 11000000  ..\n0000000e: 00001111 11000000  ..\n00000010: 00001110 11000000  ..\n00000012: 00001101 11000000  ..\n00000014: 00001100 11000000  ..\n00000016: 00001011 11000000  ..\n00000018: 00001010 11000000  ..\n0000001a: 00001001 11000000  ..\n0000001c: 00001000 11000000  ..\n0000001e: 00010001 00100100  .$\n00000020: 00011111 10111110  ..\n00000022: 11001111 11100101  ..\n00000024: 11010010 11100000  ..\n00000026: 11011110 10111111  ..\n00000028: 11001101 10111111  ..\n0000002a: 00000010 11010000  ..\n0000002c: 00000100 11000000  ..\n0000002e: 11101000 11001111  ..\n00000030: 10010000 11100000  ..\n00000032: 10000000 11100000  ..\n00000034: 00001000 10010101  ..\n00000036: 11111000 10010100  ..\n00000038: 11111111 11001111  ..\n\n```\n\n## AVR GCC\n\nThis is the main compiler I use when working with avr chips.\n\n[Supported architectures](https://gcc.gnu.org/onlinedocs/gcc/AVR-Options.html#AVR-Options)\n\n[Wiki](https://gcc.gnu.org/wiki/avr-gcc)\n\n### Standards\n\nC has published new standard for the language over time. New standards bring new features or datatypes. For an example of one I like, c99 introduced boolean datatypes. There are a number of different standards, as of 2022 theres c89, gnu89, c94, c99, gnu99, c11, gnu11, c17, gnu17, c2x, and gnu2x. I'm not sure why each release has a GNU equivalent or the history behind that, [but there are differences, mostly a couple keywords and macros](https://clang.llvm.org/docs/UsersManual.html#differences-between-various-standard-modes).\n\n**Note** use `gnu*` standards for arduino, I've seen some cases in the [SpencerKonde ATtiny core](https://github.com/SpenceKonde/ATTinyCore) where the `asm` keyword is used.\n\n### Linking\n\nThe avr-gcc compiler not only has many AVR ISAs compilation support, it also provides the linker with defaults. This means that the architecture flag `-m` needs to always be specified.\n\nFor AVRs, the interrupt table starts at 0x000. Dumping the table for an attiny85, compiled with `-mmcu=attiny85`:\n```\n> avr-objdump -S  -m avr25 loop\n...\n00000000 <__vectors>:\n   0:\t0e c0       \trjmp\t.+28     \t; 0x1e <__ctors_end>\n   2:\t15 c0       \trjmp\t.+42     \t; 0x2e <__bad_interrupt>\n   4:\t14 c0       \trjmp\t.+40     \t; 0x2e <__bad_interrupt>\n   6:\t13 c0       \trjmp\t.+38     \t; 0x2e <__bad_interrupt>\n   8:\t12 c0       \trjmp\t.+36     \t; 0x2e <__bad_interrupt>\n   a:\t11 c0       \trjmp\t.+34     \t; 0x2e <__bad_interrupt>\n   c:\t10 c0       \trjmp\t.+32     \t; 0x2e <__bad_interrupt>\n   e:\t0f c0       \trjmp\t.+30     \t; 0x2e <__bad_interrupt>\n  10:\t0e c0       \trjmp\t.+28     \t; 0x2e <__bad_interrupt>\n  12:\t0d c0       \trjmp\t.+26     \t; 0x2e <__bad_interrupt>\n  14:\t0c c0       \trjmp\t.+24     \t; 0x2e <__bad_interrupt>\n  16:\t0b c0       \trjmp\t.+22     \t; 0x2e <__bad_interrupt>\n  18:\t0a c0       \trjmp\t.+20     \t; 0x2e <__bad_interrupt>\n  1a:\t09 c0       \trjmp\t.+18     \t; 0x2e <__bad_interrupt>\n  1c:\t08 c0       \trjmp\t.+16     \t; 0x2e <__bad_interrupt>\n```\n\nCompare this to the Arduino Uno's ATmega328p, compiled with `-mmcu=atmega328p`:\n```\n> avr-objdump -S  -m avr5 loop\n...\n00000000 <__vectors>:\n   0:\t0c 94 34 00 \tjmp\t0x68\t; 0x68 <__ctors_end>\n   4:\t0c 94 3e 00 \tjmp\t0x7c\t; 0x7c <__bad_interrupt>\n   8:\t0c 94 3e 00 \tjmp\t0x7c\t; 0x7c <__bad_interrupt>\n   c:\t0c 94 3e 00 \tjmp\t0x7c\t; 0x7c <__bad_interrupt>\n  10:\t0c 94 3e 00 \tjmp\t0x7c\t; 0x7c <__bad_interrupt>\n  14:\t0c 94 3e 00 \tjmp\t0x7c\t; 0x7c <__bad_interrupt>\n  18:\t0c 94 3e 00 \tjmp\t0x7c\t; 0x7c <__bad_interrupt>\n  1c:\t0c 94 3e 00 \tjmp\t0x7c\t; 0x7c <__bad_interrupt>\n  20:\t0c 94 3e 00 \tjmp\t0x7c\t; 0x7c <__bad_interrupt>\n  24:\t0c 94 3e 00 \tjmp\t0x7c\t; 0x7c <__bad_interrupt>\n  28:\t0c 94 3e 00 \tjmp\t0x7c\t; 0x7c <__bad_interrupt>\n  2c:\t0c 94 3e 00 \tjmp\t0x7c\t; 0x7c <__bad_interrupt>\n  30:\t0c 94 3e 00 \tjmp\t0x7c\t; 0x7c <__bad_interrupt>\n  34:\t0c 94 3e 00 \tjmp\t0x7c\t; 0x7c <__bad_interrupt>\n  38:\t0c 94 3e 00 \tjmp\t0x7c\t; 0x7c <__bad_interrupt>\n  3c:\t0c 94 3e 00 \tjmp\t0x7c\t; 0x7c <__bad_interrupt>\n  40:\t0c 94 3e 00 \tjmp\t0x7c\t; 0x7c <__bad_interrupt>\n  44:\t0c 94 3e 00 \tjmp\t0x7c\t; 0x7c <__bad_interrupt>\n  48:\t0c 94 3e 00 \tjmp\t0x7c\t; 0x7c <__bad_interrupt>\n  4c:\t0c 94 3e 00 \tjmp\t0x7c\t; 0x7c <__bad_interrupt>\n  50:\t0c 94 3e 00 \tjmp\t0x7c\t; 0x7c <__bad_interrupt>\n  54:\t0c 94 3e 00 \tjmp\t0x7c\t; 0x7c <__bad_interrupt>\n  58:\t0c 94 3e 00 \tjmp\t0x7c\t; 0x7c <__bad_interrupt>\n  5c:\t0c 94 3e 00 \tjmp\t0x7c\t; 0x7c <__bad_interrupt>\n  60:\t0c 94 3e 00 \tjmp\t0x7c\t; 0x7c <__bad_interrupt>\n  64:\t0c 94 3e 00 \tjmp\t0x7c\t; 0x7c <__bad_interrupt>\n```\n\n\n## Avrdude\n\nPretty slick tool to read and write memory on your avr chip.\n\nThe Arduino platform has a pretty good integration with these tools. I found it to be helpful to turn the ide verbosity up to read the avrdude commands that are run. There's a config file that comes from whatever core you are using that might be useful.\n\nThe following examples are based on an attiny85 connected to a Sparkfun tinyIsp programmer plugged into a usb port.\n\nUpload an ihex file:\n```\n# -U [memory(flash/eeprom)]:[w/r]:[input/output file]:[i stands for intel hex]\navrdude -v -c usbtiny -B8 -p attiny85 -U flash:w:hello.hex:i\n```\n\nDump the flash:\n```\navrdude -v -c usbtiny -B8 -p attiny85 -U flash:r:dump.hex:i\navr-objdump -sSd -m avr25 dump.hex\n```\n\nTerminal mode to dump part of eeprom:\n```\navrdude -v -c usbtiny -B8 -p attiny85 -t\n>>> dump eeprom 0 16\n\nReading | ################################################## | 100% 0.02s\n\n0000  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|\n```\n\nChanging the clock speed from 8Mhz internal to 1Mhz internal. Note that the F_CPU macro in your code needs to match the fuse value. Use a fuse calculator for these.\nSetting the fuses:\n```\navrdude -v -c usbtiny -B8 -p attiny85 -t\n>>> dump lfuse\n\nReading | ################################################## | 100% 0.00s\n\n0000  e2                                                |.               |\n\n>>> write lfuse 0 0x62\n\nInfo: Writing 1 bytes starting from address 0x00\n\nWriting | ################################################## | 100% 0.01s\n\n>>> read lfuse\n\nReading | ################################################## | 100% 0.00s\n\n0000  62                                                |b               |\n```\n"},{"slug":"gcc-optimization-levels","frontmatter":{"title":"GCC Optimization Levels","date":"2022-08-10","tags":["debugger","gcc","avr"]},"content":"\nOptimization levels are really weird.\n\nUsing the function and compiling for an attiny85, ie [`--mmcu=attiny85`](https://www.nongnu.org/avr-libc/user-manual/using_tools.html).\n```\nint main(void) {\n    int i = 0;\n    while(i < 10000) {\n        i++;\n    }\n}\n```\n\nWe can disassemble with `avr-objdump -sS -m avr25 led`. As a disclaimer, I'm not pretending I know what any of this means.\n\nUsing `-Os` ie optimize for code side, it looks like the entire function is optimized away!\n```\n> avr-objdump -sS -m avr25 led\n...\n00000030 <main>:\n{\n    int i = 0;\n    while(i < 10000) {\n        i++;\n    }\n}\n  30:\t90 e0       \tldi\tr25, 0x00\t; 0\n  32:\t80 e0       \tldi\tr24, 0x00\t; 0\n  34:\t08 95       \tret\n```\n\nAnd by comparison, using `-O0`, fastest compile time and the gcc default:\n```\n00000030 <main>:\n// #include \"wait.h\"\n\nint main(void) {\n  30:\tcf 93       \tpush\tr28\n  32:\tdf 93       \tpush\tr29\n  34:\t00 d0       \trcall\t.+0      \t; 0x36 <L0^A>\n\n00000036 <L0^A>:\n  36:\tcd b7       \tin\tr28, 0x3d\t; 61\n  38:\tde b7       \tin\tr29, 0x3e\t; 62\n\n0000003a <.Loc.1>:\n    int i = 0;\n  3a:\t1a 82       \tstd\tY+2, r1\t; 0x02\n  3c:\t19 82       \tstd\tY+1, r1\t; 0x01\n\n0000003e <.Loc.2>:\n    while(i < 10000) {\n  3e:\t05 c0       \trjmp\t.+10     \t; 0x4a <.L2>\n\n00000040 <.L3>:\n        i++;\n  40:\t89 81       \tldd\tr24, Y+1\t; 0x01\n  42:\t9a 81       \tldd\tr25, Y+2\t; 0x02\n  44:\t01 96       \tadiw\tr24, 0x01\t; 1\n  46:\t9a 83       \tstd\tY+2, r25\t; 0x02\n  48:\t89 83       \tstd\tY+1, r24\t; 0x01\n\n0000004a <.L2>:\n    while(i < 10000) {\n  4a:\t89 81       \tldd\tr24, Y+1\t; 0x01\n  4c:\t9a 81       \tldd\tr25, Y+2\t; 0x02\n  4e:\t80 31       \tcpi\tr24, 0x10\t; 16\n  50:\t97 42       \tsbci\tr25, 0x27\t; 39\n  52:\tb4 f3       \tbrlt\t.-20     \t; 0x40 <.L3>\n  54:\t80 e0       \tldi\tr24, 0x00\t; 0\n  56:\t90 e0       \tldi\tr25, 0x00\t; 0\n\n00000058 <.Loc.5>:\n    }\n}\n  58:\t0f 90       \tpop\tr0\n  5a:\t0f 90       \tpop\tr0\n  5c:\tdf 91       \tpop\tr29\n  5e:\tcf 91       \tpop\tr28\n  60:\t08 95       \tret\n00000030 <main>:\n// #include \"wait.h\"\n\nint main(void) {\n  30:\tcf 93       \tpush\tr28\n  32:\tdf 93       \tpush\tr29\n  34:\t00 d0       \trcall\t.+0      \t; 0x36 <L0^A>\n\n00000036 <L0^A>:\n  36:\tcd b7       \tin\tr28, 0x3d\t; 61\n  38:\tde b7       \tin\tr29, 0x3e\t; 62\n\n0000003a <.Loc.1>:\n    int i = 0;\n  3a:\t1a 82       \tstd\tY+2, r1\t; 0x02\n  3c:\t19 82       \tstd\tY+1, r1\t; 0x01\n\n0000003e <.Loc.2>:\n    while(i < 10000) {\n  3e:\t05 c0       \trjmp\t.+10     \t; 0x4a <.L2>\n\n00000040 <.L3>:\n        i++;\n  40:\t89 81       \tldd\tr24, Y+1\t; 0x01\n  42:\t9a 81       \tldd\tr25, Y+2\t; 0x02\n  44:\t01 96       \tadiw\tr24, 0x01\t; 1\n  46:\t9a 83       \tstd\tY+2, r25\t; 0x02\n  48:\t89 83       \tstd\tY+1, r24\t; 0x01\n\n0000004a <.L2>:\n    while(i < 10000) {\n  4a:\t89 81       \tldd\tr24, Y+1\t; 0x01\n  4c:\t9a 81       \tldd\tr25, Y+2\t; 0x02\n  4e:\t80 31       \tcpi\tr24, 0x10\t; 16\n  50:\t97 42       \tsbci\tr25, 0x27\t; 39\n  52:\tb4 f3       \tbrlt\t.-20     \t; 0x40 <.L3>\n  54:\t80 e0       \tldi\tr24, 0x00\t; 0\n  56:\t90 e0       \tldi\tr25, 0x00\t; 0\n\n00000058 <.Loc.5>:\n    }\n}\n  58:\t0f 90       \tpop\tr0\n  5a:\t0f 90       \tpop\tr0\n  5c:\tdf 91       \tpop\tr29\n  5e:\tcf 91       \tpop\tr28\n  60:\t08 95       \tret\n```\n\nWith `-O1`:\n```\n00000030 <main>:\n// #include \"wait.h\"\n\nint main(void) {\n  30:\t80 e1       \tldi\tr24, 0x10\t; 16\n  32:\t97 e2       \tldi\tr25, 0x27\t; 39\n\n00000034 <.L2>:\n    int i = 0;\n    while(i < 10000) {\n  34:\t01 97       \tsbiw\tr24, 0x01\t; 1\n\n00000036 <.LVL2>:\n  36:\tf1 f7       \tbrne\t.-4      \t; 0x34 <.L2>\n\n00000038 <.Loc.8>:\n        i++;\n    }\n}\n  38:\t90 e0       \tldi\tr25, 0x00\t; 0\n  3a:\t80 e0       \tldi\tr24, 0x00\t; 0\n\n0000003c <.LVL3>:\n  3c:\t08 95       \tret\n```\n\nAnd finally with `-O2` and `-O3` we are back to optimizing everything away:\n```\n00000030 <main>:\nint main(void) {\n    int i = 0;\n    while(i < 10000) {\n        i++;\n    }\n}\n  30:\t90 e0       \tldi\tr25, 0x00\t; 0\n  32:\t80 e0       \tldi\tr24, 0x00\t; 0\n  34:\t08 95       \tret\n```\n\nSo I guess the TLDR here is try and test them all?\n\nThe case where the entire function is optimized away seems funny to me, what if you hand rolled a sleep with a big loop? Wouldn't that be grand if it just disappeared?\n"},{"slug":"temp-sensor","frontmatter":{"title":"Thermometer","date":"2022-07-21","tags":["thermometer"]},"content":"\nWhy buy a $10 thermometer when you can spend $100 and build one yourself in 15-20 hours?\n\n![Thermometer](/images/thermometer/thermometer.jpg)\n\nCaitlin kept saying the thermostat was off so I build this to find out. As a bonus, it also tells me my house is too humid so now I have to also figure that out. Fun.\n\nI was stubborn and wanted to use an attiny85 regardless of whether it was a good idea or not.\n5 pins isn't enough to control the display so I used a shift register as an IO expander to talk to the 1602 led display using SPI.\n\n![Prototype](/images/thermometer/prototype.jpg)\n\nThe temp/humidity sensor originally was an aht11 but apparently that unit is extremely sensitive to timing and I couldn't quite get it right with the attiny. I switched to an AM2301B and that used i2c for communication and worked really well.\n\nFirst try I soldered everything backwards but I eventually got it right.\n\n![Board](/images/thermometer/board.jpg)\n\n![Board2](/images/thermometer/board2.jpg)\n\n![Board3](/images/thermometer/board3.jpg)\n\n![Power Up](/images/thermometer/power-up.jpg)\n\nThe packing took forever and I ended up having to buy multiple project boxes to get the right size.\n\n![Packaging](/images/thermometer/packaging.jpg)\n\n![Assembly](/images/thermometer/assembly.jpg)\n\nAll done!\n\n![Final](/images/thermometer/final.jpg)\n"},{"slug":"bench-setup","frontmatter":{"title":"Bench Setup","date":"2022-07-16","tags":["bench"]},"content":"\n![Office](/images/office-early.jpg \"Office\")"},{"slug":"led-counter","frontmatter":{"title":"7 Segment LED Counter","date":"2022-07-15","tags":["led"]},"content":"\nThis was a funny project where I tried to build a simple 7 segment led counter without using a microcontroller. Each digit is controlled separately using 4026's and a sub 15 ms clock controlling which led is displayed, targeting a digit using a mux. 15 ms was chosen because it's faster than I could notice the counter changing, kinda like controlling led brightness using pwm. The counter ticks up based on a second slower clock or a button.\n\nI isolated the clocks into separate modules using 555 timers, both of which took forever to solder. One was in a fixed astable mode, the other a toggle-able monostable button debouncer or a bi-stable latch.\n\nRan out of diodes on this one...\n\n![LED Counter](/images/led-counter.jpg \"LED Counter\")\n"},{"slug":"first-oscillator","frontmatter":{"title":"Simple Oscillator","date":"2022-07-10","tags":["oscillator"]},"content":"\n![Oscillator](/images/first-oscillator.jpg \"An Oscillator\")\n\nProbably the first circuit I tried to solder together. An astable oscillator that was so\nastable the timing was all over the place!\n"}]},"__N_SSG":true}